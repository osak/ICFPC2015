#! /usr/bin/python
__author__ = 'shunsuke'

from flask import Flask, render_template, request, url_for
import pymongo
from config import MONGO_URI, HIBIKI_HOST, HIBIKI_PORT, ENVIRONMENT
import logging
import datetime
import urllib2
import urllib
import json

logger = logging.getLogger('hibiki')
app = Flask(__name__)


def my_url_for(endpoint, **values):
    if ENVIRONMENT == "prod":
        return "/hibiki" + url_for(endpoint, **values)
    else:
        return url_for(endpoint, **values)


@app.context_processor
def utility_processor():
    return dict(my_url_for=my_url_for)


def get_poyo_score():
    body = urllib2.urlopen('https://davar.icfpcontest.org/rankings.js').read()
    score_json = json.loads(body[10:])
    result = dict()
    for setting in score_json['data']['settings']:
        setting_id = setting['setting']
        ranking = setting['rankings']
        for submission in ranking:
            if submission['teamId'] != 9:
                continue
            result[setting_id] = submission['score']
    return result


def get_submission_scores(revs, poyo, allrevs=False):
    client = pymongo.MongoClient(MONGO_URI)
    logger.info('collect score info.')
    query = {'score': {'$exists': True}}
    if not allrevs:
        query['revision'] = {'$in': revs}
    cursor = client.kadingel.output.find(query, projection={'_id': False})
    documents = list(cursor)
    client.close()

    used_tuple = set()
    revset = set(revs)
    summary, names, runtime = dict(), dict(), dict()
    for document in documents:
        tup = (document['revision'], document['problemId'], document['seed'])
        if tup not in used_tuple:
            used_tuple.add(tup)
            rev, prob_id, seed = tup
            if prob_id not in summary:
                summary[prob_id] = dict()
                runtime[prob_id] = dict()
            if rev not in summary[prob_id]:
                summary[prob_id][rev] = []
                runtime[prob_id][rev] = []
            summary[prob_id][rev].append(document['score'])
            runtime[prob_id][rev].append(document['elapsedTime'])
            names[rev] = document['comment']
    if poyo:
        revset.add('poyo')
        names['poyo'] = '7th_building'
        for prob_id, score in get_poyo_score().items():
            if prob_id not in summary:
                summary[prob_id] = dict()
                runtime[prob_id] = dict()
            summary[prob_id]['poyo'] = [score]

    best = dict()
    for prob_id, row in summary.items():
        for rev, scores in row.items():
            row[rev] = sum(scores) / len(scores)
        for rev in revs:
            if rev not in row:
                row[rev] = 0
        best[prob_id] = max(row.values())
    for prob_id, row in runtime.items():
        for rev, times in row.items():
            row[rev] = '{:0.3f}'.format(sum(times) / len(times))
        for rev in revs + ['poyo']:
            if rev not in row:
                row[rev] = '----'

    return summary, names, best, documents, runtime


def get_submission_data(bestrev):
    docs = get_all_output()
    submission_data = []
    for doc in docs:
        if doc["revision"] == bestrev[doc["problemId"]]:
            submission_data.append(doc)
    return submission_data


def submit_data(docs):
    solution = json.dumps(docs)
    logger.info("solution length: {}".format(len(solution)))
    datadic = {'solution': solution, 'comment': 'submission generated by Hibiki at {}'.format(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))}
    data = urllib.urlencode(datadic)
    handler = urllib2.HTTPHandler()
    opener = urllib2.build_opener(handler)
    request = urllib2.Request('http://icfpc.osak.jp/ogawa/solution', data=data)
    request.get_method = lambda: "POST"
    try:
        connection = opener.open(request)
    except urllib2.HTTPError, e:
        connection = e

    if connection.code == 200:
        logger.info("Submission Success")
        return True
    else:
        logger.warning("Submission Failure")
        logger.warning(connection)
        return False


def get_best_rev_score(summary):
    bestrev = dict()
    bestscore = dict()
    for prob_id in summary:
        maxrev, maxscore = max(summary[prob_id].items(), key=lambda tup: tup[1])
        bestrev[prob_id] = maxrev
        bestscore[prob_id] = maxscore
    return bestrev, bestscore


@app.route("/submission", methods=["GET", "POST"])
def submission():
    context = dict()
    if request.method == "POST":
        bestrev = dict()
        for key, value in request.form.items():
            if key.startswith('rev:'):
                bestrev[int(key[4:])] = value
        submission_data = get_submission_data(bestrev)
        logger.info("submission data length = {}".format(len(submission_data)))
        context["message"] = "Success!" if submit_data(submission_data) else "Failure..."
        # fall through to get proessing
    summary, names, best, docs, runtime = get_submission_scores([], False, allrevs=True)
    bestrev, bestscore = get_best_rev_score(summary)
    return render_template('submission.html', names=names, problems=summary.keys(), bestrev=bestrev, bestscore=bestscore, **context)


@app.route("/compare")
def compare():
    context = dict()
    revs = request.args.get('revs')
    if revs:
        revs = revs.split(',')
    else:
        revs = []
    poyo = bool(request.args.get('poyo'))
    global_best = bool(request.args.get('best'))
    summary, names, best, docs, runtime = get_submission_scores(revs, poyo)
    if global_best:
        global_best_rev, global_best_score = get_best_rev_score(get_submission_scores([], False, allrevs=True)[0])
        context['global_best_rev'] = global_best_rev
        context['global_best_score'] = global_best_score
    return render_template('compare.html', revs=names.keys(), names=names, problems=summary.keys(), summary=summary, best=best, runtime=runtime, **context)


def get_all_output(query=None):
    if query is None:
        query = {}
    client = pymongo.MongoClient(MONGO_URI)
    logger.info('collect all output.')
    cursor = client.kadingel.output.find(query, projection={'_id': False})
    # documents = list(cursor.sort([('runDateUtc', pymongo.DESCENDING), ('problemId', pymongo.ASCENDING), ('seed', pymongo.ASCENDING)]))
    documents = list(cursor)

    client.close()
    # filter duplicated docs
    result = []
    used_tuple = set()
    for document in documents:
        tup = (document['revision'], document['problemId'], document['seed'])
        if tup not in used_tuple:
            result.append(document)
            used_tuple.add(tup)
    return result


def render_output_table_page(query, template_name):
    outputs = get_all_output(query=query)
    outputs.sort(key=lambda doc: (-int(doc['runDateUtc']), doc['problemId'], doc['seed']))
    output_base_url = 'http://icfpc.osak.jp/akatsuki/{api}/{problemId}/{seed}/{revision}/'
    visualiser_base_url = 'http://icfpc.osak.jp/nastasja/index.html?revision={revision}&problemId={problemId}&seed={seed}'
    for output in outputs:
        output['outputUrl'] = output_base_url.format(api='output', **output)
        output['visualizerUrl'] = visualiser_base_url.format(api='game', **output)
        datetime_obj = datetime.datetime.fromtimestamp(int(output['runDateUtc']))
        output['runDateString'] = datetime_obj.strftime("%Y-%m-%d %H:%M:%S")
        output['elapsedTime'] = '{:0.3f}'.format(output['elapsedTime'])
    return render_template(template_name,
                           outputs=outputs)


@app.route("/revision/<revision>")
def view_revision(revision):
    return render_output_table_page({'revision': revision}, 'view_revision.html')


@app.route("/viewall")
def viewall():
    return render_output_table_page({}, 'viewall.html')


@app.route("/")
def index():
    return render_output_table_page({'problemId': 0, 'seed': 0}, 'index.html')


if __name__ == "__main__":
    message_level = logging.WARN if ENVIRONMENT == "prod" else logging.INFO
    logging.basicConfig(level=message_level)
    app.run(host=HIBIKI_HOST, port=HIBIKI_PORT)
